Для запуска тестов достаточно запустить `make.do` скрипт

Ошибки выводятся в формате: `{time} ns: {name} expected {ref_val} but got {dut_val}`

Для наглядности и чтобы не загромождать консоль вывода я рекомендую проводить один тест за раз. Для этого в файле [lifo_tb.sv](./tb/lifo_tb.sv#157) необходимо закомментировать все тесты кроме одного желаемого. Далее все тайминги будут приведены имеено в таком формате.

Hint: для наглядности потока данных в файле [lifo_generator.sv](./tb/lifo_generator.sv#L58) строку `this._if.data  <= $urandom_range( 0, ( 2 ** DWIDTH - 1 ) );` можно заменить на `this._if.data  <= i;`

# 1 Version
- `empty_o`:        не выставляется в ноль при старте симуляции. После записи/чтения сигнал работает корректно. (`15 ns`)
- `almost_full_o`:  работает по обратному принципу: значение выставляется в `1` если количество СВОБОДНОГО места остаётся <= `ALMOST_FULL_VALUE` (`1035 ns`)
- `almost_empty_o`: сигнал опаздывает на 1 такт (`7115 ns`)
- `usedw_o`:        при записи в полную очередь (`13725 ns`) или при чтении из пустой очереди (`23955 ns`) счётчик работает некорректно
- `q_o`:            при чтении из полной очереди будто пропускает 1 запрос (`23955 ns`)

# 2 Version
- `test_full_write`: тесты проходят успешно
- `test_full_read`:
    - (1) при чтении из полной очереди модуль пропускает один запрос на чтение (`2575 ns`). `usedw` при этом обновляется корректно
    - (2) при записи в пустую lifo, данные "исчезают". в `15 ns` записывается число `60200`, а затем `10436`. во время чтения в `5135 ns` последнее значение которое выдаёт модуль это `10436`. Возможно (1) и (2) взаимосвязаны
- `test_read_write`:
    - (3) при одновременном чтении и записи из пустой lifo запрос на запись игнорируется (`15 ns`)
- `test_overflow_write`: тесты проходят успешно
- `test_read_from_empty`:
    - (4) при чтении из пустой очедени `q_o` выдаёт `x`
- `test_random`: кажется, что все ошибки уже были описаны выше
